<html>
<head>
  <title>js-闭包和继承</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/303788 (zh-CN, DDL); Windows/6.1.7601 Service Pack 1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="724"/>
<h1>js-闭包和继承</h1>

<div>
<span><div style="display: block; margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-align: center;"><div><span style="font-size: 32px;">js-闭包和继承</span></div></div><div style="display: block; margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><br/></div><div style="display: block; margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-align: right;"><div style="display: block; margin: 0px; padding: 0px; text-align: right;"><div><span style="font-size: 16px;">作者： 千锋李文浩</span></div></div></div><div style="display: block; margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-align: right;"><div><span style="font-size: 16px;">时间：   17/02/21</span></div></div><div><br/></div><div><br/></div><div><span style="color: rgb(173, 0, 0);"><span style="font-size: 16px;"><b>Promise</b></span></span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">1、什么是Promise？</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><br/></span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     a、<span style="color: rgb(227, 0, 0);"><b>实现异步编程的一种方案</b></span>，比异步嵌套和回调函数更合理、强大。</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     b、Promise本身是一个对象，通过Promise可以获取异步操作的信息（异步是否完成）</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><br/></span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    <span style="color: rgb(173, 0, 0);"><b> 学习链接</b></span>：</span></span></span><a href="http://www.cnblogs.com/whitewolf/archive/2015/10/22/4902570.html">http://www.cnblogs.com/whitewolf/archive/2015/10/22/4902570.html</a></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><br/></span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">2、Promise有什么用？</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     1、将异步编程思维简单化</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     2、多个异步任务的串行处理（先执行第一个异步，完成后执行第二个异步...）</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     3、多个异步任务的并行处理（同时执行多个异步操作，等待所有的异步操作完成才能做其他事情。）</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     </span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">3、<span style="color: rgb(227, 0, 0);">怎么创建一个Promise对象？</span></span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     var p = new Promise(function(resolve,reject){</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">          //resolve 1、用于通知Promise对象异步程序成功了 (resolve() ) 2、是个方法 </span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">          //reject 1、用于通知Promise对象异步程序失败了 (reject() ) 2、是个方法 </span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">          //异步代码</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     });</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     //p此时就是一个Promise对象</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     <span style="color: rgb(227, 0, 0);">说明：创建Promise对象的时候，异步代码就会执行</span></span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><br/></span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">4、<span style="color: rgb(227, 0, 0);">怎么实现2个异步任务串行？</span></span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     var p1 = new Promise(function(resolve){</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">          //第一个异步程序</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">          setTimeout(function(){</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">               console.log(1);</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">               //异步完成通知Promise异步完成了，可以执行其他异步了</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">          },1000);</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     });</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><br/></span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     //实现多个异步程序串行</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     p1.then(function(){</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">          //第二个异步程序</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">          setTimeout(function(){</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">               console.log(2);</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">               //异步完成通知Promise异步完成了，可以执行其他异步了</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">          },2000);</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     });</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="color: rgb(173, 0, 0);"><b><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">5、怎么实现多个异步程序串行？</span></span></b></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">     </span></span></span><img src="js-闭包和继承_files/Image.png" type="image/png" style="height:auto;" width="343.8"/></div><div><br/></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">6、<span style="color: rgb(227, 0, 0);"><b>Promise异步处理程序之间怎么传递参数？</b></span></span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   p1.then(f1,f2)</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   then方法可以传递两个函数，f1是p1成功时调用(resove())，f2是p1失败时调用(reject())，</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   参数可以通过resolve方法或者reject方法传递，如：</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   var p1 = new Promise(function(resolve){</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        setTimeout(function(){</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">             console.log('第一个异步结束了');</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">             //通知promise并传递参数</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">             resolve('我是传递过来的数据');<br/></span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        });<br/></span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   });</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    p1.then(function(data){}</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">          //data 是p1中异步程序结束之后resolve函数传递过来的  </span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">          console.log(data);//</span></span></span><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">'我是传递过来的数据'</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">          setTimeout(function(){</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">          </span></span></span> <span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">     console.log('第二个异步结束了');</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">          });<br/></span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">     );<br/></span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"> </span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">7、怎么实现多个异步操作并行？</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     所谓并行，指的就是多个异步程序同时处理</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">      var p1 = new Promise(function(resolve){</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">          //第一个异步程序</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">          setTimeout(function(){</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">               console.log(1);</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">               //异步完成通知Promise异步完成了，可以执行其他异步了</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">               resolve();<br/></span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">          },1000);</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     });</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     var p2 = new Promise(function(resolve){</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">          //第二个异步程序</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">          setTimeout(function(){</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">               console.log(2);</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">               //异步完成通知Promise异步完成了，可以执行其他异步了</span></span></span></div><div>                         <span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco;">resolve();</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">          },2000);</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     });</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><br/></span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     var pAll = Promise.all([p1,p2]);</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     pAll.then(functuion(){</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">          console.log('所有异步程序完成了');</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     });</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     </span></span></span></div></div><div><br/></div><div><br/></div><div><span style="font-size: 16px;"><b>实战</b></span></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>通过学生姓名读取学生信息和成绩</div></div><div><br/></div><div><br/></div><div><span style="color: rgb(173, 0, 0);"><b>思考</b></span></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>怎么读取函数内的局部变量？</div></div><div><b><span style="font-size: 16px;"><span style="color: rgb(173, 0, 0);"><br/></span></span></b></div><div><span style="color: rgb(173, 0, 0);"><span style="font-size: 16px;"><b>垃圾回收机制（扩展）</b></span></span></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>1、一般来说,一个函数在执行开始的时候,会给其中定义的变量划分内存空间保存,以备后面的语句所用,<span style="color: rgb(227, 0, 0);">等到函数执行完毕返回了,这些变量就被认为是无用的了.对应的内存空间也就被回收了</span>.下次再执行此函数的时候,所有的变量又回到最初的状态,重新赋值使用.     </div><div><br/></div><div>2、但是如果这个函数内部又嵌套了另一个函数,而这个函数是有可能在外部被调用到的.并且这个内部函数又使用了外部函数的某些变量的话.这种内存回收机制就会出现问题.如果在外部函数返回后,又直接调用了内部函数,那么内部函数就无法读取到他所需要的外部函数中变量的值了    </div><div><br/></div><div>3、<span style="color: rgb(227, 0, 0);"><b>函数中的函数一旦被外界引用，浏览器将不回收创建的内存</b></span></div></div><div><br/></div><div><br/></div><div><span style="font-size: 16px;"><span style="color: rgb(173, 0, 0);"><b>面试题（重）</b></span></span></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>1、什么是闭包？</div><div>2、闭包有什么用？</div><div>3、说几个闭包的使用场景</div></div><div><br/></div><div><br/></div><div><span style="color: rgb(173, 0, 0);"><b>什么是闭包？（重）</b></span></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>1、官方：闭包是指可以包含自由（未绑定到特定对象）变量的代码块；这些变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义（局部变量）。</div><div><br/></div><div>2、简单理解：<span style="color: rgb(173, 0, 0);"><b>闭包就是在函数A外部能够访问函数A内部变量的函数</b></span></div><div><b><span style="color: rgb(173, 0, 0);"><br/></span></b></div><div><b><span style="color: rgb(173, 0, 0);">function test(){</span></b></div><div><b><span style="color: rgb(173, 0, 0);">     var a = 10;<br/></span></b></div><div><b><span style="color: rgb(173, 0, 0);">     return function(){</span></b></div><div><b><span style="color: rgb(173, 0, 0);">         console.log(a);<br/></span></b></div><div><b><span style="color: rgb(173, 0, 0);">     }<br/></span></b></div><div><b><span style="color: rgb(173, 0, 0);">}</span></b></div><div><b><span style="color: rgb(173, 0, 0);">//fn就是闭包（也就是返回的匿名函数）</span></b></div><div><b><span style="color: rgb(173, 0, 0);">var fn = test();</span></b></div><div><b><span style="color: rgb(173, 0, 0);"><br/></span></b></div><div><b><span style="color: rgb(173, 0, 0);">fn()</span></b></div></div><div><br/></div><div><br/></div><div><span style="color: rgb(173, 0, 0);"><span style="font-size: 16px;"><b>闭包的作用（重）</b></span></span></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>1、可以读取可控制函数内部的变量  </div><div><br/></div><div>2、让变量的值始终保持在内存中  </div><div><br/></div><div>3、保护函数内的变量安全。（只能通过闭包函数访问）</div></div><div><br/></div><div><br/></div><div><span style="font-size: 16px;"><span style="color: rgb(173, 0, 0);"><b>闭包的使用场景（重）</b></span></span></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>1、循环保留变量i的值</div><div><br/></div><div>2、函数自运行</div><div><br/></div><div>3、获取函数内部的变量</div></div><div><br/></div><div><br/></div><div><span style="font-size: 16px;"><span style="color: rgb(173, 0, 0);"><b>闭包说明</b></span></span></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>1、不要刻意的使用闭包，尽量少使用闭包。</div><div><br/></div><div>2、闭包就会开辟内存，可能造成内存泄漏</div></div><div><br/></div><div><br/></div><div><span style="font-size: 16px;"><b>实战</b></span></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>1、我的银行</div><div><br/></div><div>2、循环添加事件</div><div><br/></div><div>3、自运行</div></div><div><br/></div><div><br/></div><div><span style="font-size: 16px;"><span style="color: rgb(173, 0, 0);"><b>构造函数（回顾）</b></span></span></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>1、什么是构造函数？</div><div>   代表的是含有相同特征的事物（类）</div><div>2、构造函数怎么声明？有什么特点？</div><div>   function Person(name){</div><div>      this.name = name;</div><div>      this.eat = function(){}</div><div>   }</div><div><br/></div><div>   var p = new Person();</div></div><div><br/></div><div><br/></div><div><span style="font-size: 16px;"><b>思考</b></span></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>function Person(name){</div><div>     this.name = name;</div><div>     this.speak = function(){</div><div>          console.log(this.name + &quot;正在自言自语&quot;);</div><div>     }</div><div>}</div><div><br/></div><div>var zs = new Person('张三');</div><div>var ls = new Person('李四');</div><div><br/></div><div>张三的speak方法和李四的speak方法是同一个方法吗？</div><div><br/></div><div>怎么才能让张三和李四共用一个speak方法？</div><div>zs.speak == ls.speak</div><div><br/></div></div><div><br/></div><div><br/></div><div><span style="font-size: 16px;"><span style="color: rgb(173, 0, 0);"><b>原型protorype（重）</b></span></span></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>1、什么是原型？</div><div><br/></div><div>     1、prototype是函数自带的<span style="color: rgb(227, 0, 0);">一个属性</span></div><div>     2、prototype属性指向了<span style="color: rgb(227, 0, 0);">一个对象</span>（原型对象），简称原型，所以prototype称为原型。</div><div>     </div><div>2、原型有什么用？</div><div>     1、 节约内存开支</div><div>         将构造函数（类）的公用方法写在原型中，生成的实例所拥有的方法都是指向同一个地址，这样可以节省内存。  </div><div>   </div><div>     2、扩展属性和方法</div><div> </div><div>     3、可以很好的实现类之间的继承</div><div><br/></div><div>3、怎么使用原型给构造函数的实例添加方法</div><div>     1、因为prototype是个对象，所以可以直接添加属性和方法</div><div>     2、</div><div>          function Person(){</div><div>               </div><div>          }</div><div>          Person.prototype.eat = function(){</div><div>               //扩展方法</div><div>          }</div></div><div><br/></div><div><br/></div><div><span style="font-size: 16px;"><span style="color: rgb(173, 0, 0);"><b>__proto__（重）</b></span></span></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>1、是对象自带的一个属性</div><div>2、__proto__指向的是创造的自己那个构造函数的原型</div><div><br/></div><div>fucntion Person(){}</div><div><br/></div><div>var p = new Person();</div><div><br/></div><div>p.__proto__ === Person.prototype</div></div><div><br/></div><div><span style="font-size: 16px;"><span style="color: rgb(173, 0, 0);"><b>prototype/__proto__/constructor(重)</b></span></span></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><img src="js-闭包和继承_files/Image [1].png" type="image/png"/></div></div><div><br/></div><div><br/></div><div><span style="color: rgb(173, 0, 0);"><span style="font-size: 16px;"><b>call和apply（重）</b></span></span></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>1、所有函数自带的方法</div><div><br/></div><div>2、call</div><div style="margin-left:40px;">用于改变方法的调用者（让obj去调用方法）</div><div style="margin-left:40px;">用于改变this指向的（将方法中的this指向obj）</div><div>写法：</div><div>     方法名.call(obj,arg1,arg2,....)</div><div>参数说明：</div><div>    第一个参数是对象，后面的就是函数对应的形参</div><div><br/></div><div>apply 与 call的作用是一样的</div><div>传递参数不一样</div><div>方法名.apply(obj,集合); 集合可以是数组、arguments、元素集合</div><div><br/></div><div>3、demo：</div><div><img src="js-闭包和继承_files/Image [2].png" type="image/png" style="height:auto;" width="423.0909090909091"/></div><div><img src="js-闭包和继承_files/Image [3].png" type="image/png" style="height:auto;" width="427.18181818181824"/></div><div><img src="js-闭包和继承_files/Image [4].png" type="image/png" style="height:auto;" width="429.4545454545455"/></div><div>     </div></div><div><br/></div><div><br/></div><div><span style="color: rgb(173, 0, 0);"><span style="font-size: 16px;"><b>什么是继承</b></span></span></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><br/></div></div><div><br/></div><div><br/></div><div><span style="font-size: 16px;"><span style="color: rgb(173, 0, 0);"><b>继承方式（重）</b></span></span></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>1、构造函数继承</div><div><br/></div><div>2、call/apply继承</div><div><br/></div><div>3、原型链继承</div><div><br/></div><div>4、混合继承（常用）</div></div><div><br/></div><div><br/></div><div><span style="font-size: 16px;"><b>预习</b></span></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>1、什么是继承？</div><div>2、继承有哪些方式？</div><div>3、什么是原型链？</div><div>4、分析飞机大战中有哪些对象？每个对象有什么功能？</div></div><div><br/></div><div><br/></div></span>
</div></body></html> 